-- GTFS SQL dump generated by gtfs-via-postgres v4.10.3
-- https://github.com/public-transport/gtfs-via-postgres/tree/4.9.0
-- options:
-- {
--   silent: false,
--   requireDependencies: true,
--   ignoreUnsupportedFiles: true,
--   routeTypesScheme: 'google-extended',
--   tripsWithoutShapeId: false,
--   routesWithoutAgencyId: false,
--   stopsWithoutLevelId: true,
--   stopsLocationIndex: false,
--   lowerCaseLanguageCodes: false,
--   statsByRouteIdAndDate: 'view',
--   statsByAgencyIdAndRouteIdAndStopAndHour: 'view',
--   statsActiveTripsByHour: 'view',
--   schema: 'gtfs',
--   postgraphile: false,
--   postgraphilePassword: null,
--   postgrest: false,
--   postgrestPassword: null,
--   postgrestQueryCostLimit: null,
--   importMetadata: false,
--   importStart: 1746763002630
-- }

\set ON_ERROR_STOP on
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE SCHEMA IF NOT EXISTS "gtfs";

-- gtfs-via-postgres supports importing >1 GTFS datasets into 1 DB, each dataset within its own schema. See https://github.com/public-transport/gtfs-via-postgres/issues/51 for more information.
-- Because almost all helper utilities (enums, functions, etc.) are schema-specific, they get imported more than once. In order to prevent subtle bugs due to incompatibilities among two schemas imported by different gtfs-via-postgres versions, we mock a "mutex" here by checking for public.gtfs_via_postgres_import_version()'s return value.

-- todo: this can be done more elegantly: just a "DO" block, "ASSERT" that the version matches, create gtfs_via_postgres_import_version() in the "EXCEPTION" block
CREATE FUNCTION pg_temp.get_gtfs_via_postgres_import_version()
RETURNS TEXT
AS $$
	DECLARE
		res TEXT;
	BEGIN
		SELECT public.gtfs_via_postgres_import_version() INTO res;
		RETURN res;
	EXCEPTION
		WHEN undefined_function THEN
			-- do nothing, silence error
			RETURN NULL;
	END;
$$
LANGUAGE plpgsql;

DO $$
BEGIN
	IF EXISTS (
		SELECT version
		FROM (
			SELECT pg_temp.get_gtfs_via_postgres_import_version() AS version
		) t
		WHERE version != '4.10.3'
	) THEN
		RAISE EXCEPTION 'existing GTFS data imported with an incompatible version of gtfs-via-postgres';
	END IF;
END
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.gtfs_via_postgres_import_version()
RETURNS TEXT
AS $$
	SELECT '4.10.3'
$$
LANGUAGE sql;

-- is_valid_lang_code
-----------------

-- Unfortunately information_schema.collations.collation_name only has
-- identifiers with "_", not with "-", so we use pg_collation instead.
-- https://www.postgresql.org/docs/current/infoschema-collations.html
-- https://www.postgresql.org/docs/current/catalog-pg-collation.html
-- todo [breaking]: rename to e.g. is_similar_to_bcp_47_tag?
CREATE OR REPLACE FUNCTION "gtfs".is_bcp_47_tag(
	input TEXT
)
RETURNS BOOLEAN
AS $$
	SELECT EXISTS (
		SELECT collctype
		FROM pg_collation
		WHERE collctype = input
		OR collname = input
		OR collname = input || '-x-icu'
		LIMIT 1
	);
$$ language sql STABLE;


-- todo [breaking]: remove
CREATE OR REPLACE FUNCTION "gtfs".is_valid_lang_code(
	input TEXT
)
RETURNS BOOLEAN
AS $$
	-- todo: see also https://github.com/MobilityData/gtfs-validator/issues/1987
	SELECT "gtfs".is_bcp_47_tag(input);
$$ language sql STABLE;

-- is_timezone
-----------------

-- https://justatheory.com/2007/11/postgres-timezone-validation/
CREATE OR REPLACE FUNCTION "gtfs".is_timezone(
	tz TEXT
)
RETURNS BOOLEAN
AS $$
	DECLARE
	    date TIMESTAMPTZ;
	BEGIN
	    date := now() AT TIME ZONE tz;
	    RETURN TRUE;
	EXCEPTION WHEN invalid_parameter_value THEN
	    RETURN FALSE;
	END;
$$ language plpgsql STABLE;

-- shapes
-----------------

CREATE TABLE "gtfs".shapes (
	id SERIAL PRIMARY KEY,
	shape_id TEXT,
	shape_pt_sequence INT,
	shape_pt_loc geography(POINT),
	shape_dist_traveled REAL
);

CREATE INDEX shapes_by_shape_id ON "gtfs".shapes (shape_id);
CREATE INDEX ON "gtfs".shapes (shape_id, shape_pt_sequence);

CREATE OR REPLACE VIEW "gtfs".shapes_aggregated AS
SELECT
	shape_id,
	array_agg(shape_dist_traveled) AS distances_travelled,
	-- todo [breaking]: make this a geography!
	ST_MakeLine(array_agg(shape_pt_loc)) AS shape
FROM (
	SELECT
		shape_id,
		shape_dist_traveled,
		ST_AsText(shape_pt_loc)::geometry AS shape_pt_loc
	FROM "gtfs".shapes
	ORDER by shape_id, shape_pt_sequence
) shapes
GROUP BY shape_id;

-- shape_exists
-----------------

CREATE OR REPLACE FUNCTION "gtfs".shape_exists(
	some_shape_id TEXT
)
RETURNS BOOLEAN
AS $$
	SELECT EXISTS (
		SELECT shape_id
		FROM "gtfs".shapes
		WHERE shape_id = some_shape_id
		LIMIT 1
	);
$$ language sql STABLE;

-- calendar
-----------------

CREATE TYPE "gtfs".availability AS ENUM (
	'not_available' -- 0 – Service is not available for Mondays in the date range.
	, 'available' -- 1 – Service is available for all Mondays in the date range.
);
CREATE CAST ("gtfs".availability AS text) WITH INOUT AS IMPLICIT;

CREATE TABLE "gtfs".calendar (
	service_id TEXT PRIMARY KEY,
	monday "gtfs".availability NOT NULL,
	tuesday "gtfs".availability NOT NULL,
	wednesday "gtfs".availability NOT NULL,
	thursday "gtfs".availability NOT NULL,
	friday "gtfs".availability NOT NULL,
	saturday "gtfs".availability NOT NULL,
	sunday "gtfs".availability NOT NULL,
	start_date DATE NOT NULL,
	end_date DATE NOT NULL
);

-- calendar_dates
-----------------

CREATE TYPE "gtfs".exception_type_v AS ENUM (
	'added' -- 1 – Service has been added for the specified date.
	, 'removed' -- 2 – Service has been removed for the specified date.
);
CREATE CAST ("gtfs".exception_type_v AS text) WITH INOUT AS IMPLICIT;

CREATE TABLE "gtfs".calendar_dates (
	service_id TEXT NOT NULL,
	"date" DATE NOT NULL,
	PRIMARY KEY (service_id, "date"),
	exception_type "gtfs".exception_type_v NOT NULL
);

CREATE INDEX ON "gtfs".calendar_dates (service_id);
CREATE INDEX ON "gtfs".calendar_dates (exception_type);

-- service_days
-----------------

-- todo [breaking]: rename to service_dates?
CREATE MATERIALIZED VIEW "gtfs".service_days AS
SELECT
	base_days.service_id,
	base_days.date

-- "base" service days
FROM (
	SELECT
		service_id,
		"date"
	FROM (
		SELECT
			service_id,
			"date",
			extract(dow FROM "date") dow,
			sunday,
			monday,
			tuesday,
			wednesday,
			thursday,
			friday,
			saturday
		FROM (
			SELECT
				*,
				generate_series(
					start_date::TIMESTAMP,
					end_date::TIMESTAMP,
					'1 day'::INTERVAL
				) "date"
			FROM "gtfs".calendar
		) all_days_raw
	) all_days
	WHERE (sunday = 'available' AND dow = 0)
	OR (monday = 'available' AND dow = 1)
	OR (tuesday = 'available' AND dow = 2)
	OR (wednesday = 'available' AND dow = 3)
	OR (thursday = 'available' AND dow = 4)
	OR (friday = 'available' AND dow = 5)
	OR (saturday = 'available' AND dow = 6)
) base_days

-- "removed" exceptions
LEFT JOIN (
	SELECT *
	FROM "gtfs".calendar_dates
	WHERE exception_type = 'removed'
) removed
ON base_days.service_id = removed.service_id
AND base_days.date = removed.date
WHERE removed.date IS NULL

-- "added" exceptions
UNION SELECT service_id, "date"
FROM "gtfs".calendar_dates
WHERE exception_type = 'added'

ORDER BY service_id, "date";

CREATE UNIQUE INDEX ON "gtfs".service_days (service_id, date);

CREATE INDEX ON "gtfs".service_days (service_id);
CREATE INDEX ON "gtfs".service_days (date);
-- apparently the unique index (service_id, date) doesn't speed up queries
CREATE INDEX ON "gtfs".service_days (service_id, date);

-- agency
-----------------

CREATE TABLE "gtfs".agency (
	agency_id TEXT PRIMARY KEY,
	agency_name TEXT NOT NULL,
	agency_url TEXT NOT NULL,
	agency_timezone TEXT NOT NULL
		CONSTRAINT valid_timezone CHECK ("gtfs".is_timezone(agency_timezone)),
	agency_lang TEXT, -- todo: validate?
	agency_phone TEXT,
	agency_fare_url TEXT,
	agency_email TEXT
);

-- routes
-----------------

CREATE TYPE "gtfs".route_type_val AS ENUM (
	-- basic types
	'0' -- 0 – Tram, Streetcar, Light rail. Any light rail or street level system within a metropolitan area.
	, '1' -- 1 – Subway, Metro. Any underground rail system within a metropolitan area.
	, '2' -- 2 – Rail. Used for intercity or long-distance travel.
	, '3' -- 3 – Bus. Used for short- and long-distance bus routes.
	, '4' -- 4 – Ferry. Used for short- and long-distance boat service.
	, '5' -- 5 – Cable tram. Used for street-level rail cars where the cable runs beneath the vehicle, e.g., cable car in San Francisco.
	, '6' -- 6 – Aerial lift, suspended cable car (e.g., gondola lift, aerial tramway). Cable transport where cabins, cars, gondolas or open chairs are suspended by means of one or more cables.
	, '7' -- 7 – Funicular. Any rail system designed for steep inclines.
	, '11' -- 11 – Trolleybus. Electric buses that draw power from overhead wires using poles.
	, '12' -- 12 – Monorail. Railway in which the track consists of a single rail or a beam.

	-- extended types
, '100' -- Railway Service
, '101' -- High Speed Rail Service
, '102' -- Long Distance Trains
, '103' -- Inter Regional Rail Service
, '104' -- Car Transport Rail Service
, '105' -- Sleeper Rail Service
, '106' -- Regional Rail Service
, '107' -- Tourist Railway Service
, '108' -- Rail Shuttle (Within Complex)
, '109' -- Suburban Railway
, '110' -- Replacement Rail Service
, '111' -- Special Rail Service
, '112' -- Lorry Transport Rail Service
, '113' -- All Rail Services
, '114' -- Cross-Country Rail Service
, '115' -- Vehicle Transport Rail Service
, '116' -- Rack and Pinion Railway
, '117' -- Additional Rail Service
, '200' -- Coach Service
, '201' -- International Coach Service
, '202' -- National Coach Service
, '203' -- Shuttle Coach Service
, '204' -- Regional Coach Service
, '205' -- Special Coach Service
, '206' -- Sightseeing Coach Service
, '207' -- Tourist Coach Service
, '208' -- Commuter Coach Service
, '209' -- All Coach Services
, '400' -- Urban Railway Service
, '401' -- Metro Service
, '402' -- Underground Service
, '403' -- Urban Railway Service
, '404' -- All Urban Railway Services
, '405' -- Monorail
, '700' -- Bus Service
, '701' -- Regional Bus Service
, '702' -- Express Bus Service
, '703' -- Stopping Bus Service
, '704' -- Local Bus Service
, '705' -- Night Bus Service
, '706' -- Post Bus Service
, '707' -- Special Needs Bus
, '708' -- Mobility Bus Service
, '709' -- Mobility Bus for Registered Disabled
, '710' -- Sightseeing Bus
, '711' -- Shuttle Bus
, '712' -- School Bus
, '713' -- School and Public Service Bus
, '714' -- Rail Replacement Bus Service
, '715' -- Demand and Response Bus Service
, '716' -- All Bus Services
, '800' -- Trolleybus Service
, '900' -- Tram Service
, '901' -- City Tram Service
, '902' -- Local Tram Service
, '903' -- Regional Tram Service
, '904' -- Sightseeing Tram Service
, '905' -- Shuttle Tram Service
, '906' -- All Tram Services
, '1000' -- Water Transport Service
, '1100' -- Air Service
, '1200' -- Ferry Service
, '1300' -- Aerial Lift Service
, '1400' -- Funicular Service
, '1500' -- Taxi Service
, '1501' -- Communal Taxi Service
, '1502' -- Water Taxi Service
, '1503' -- Rail Taxi Service
, '1504' -- Bike Taxi Service
, '1505' -- Licensed Taxi Service
, '1506' -- Private Hire Service Vehicle
, '1507' -- All Taxi Services
, '1700' -- Miscellaneous Service
, '1702' -- Horse-drawn Carriage
);
CREATE CAST ("gtfs".route_type_val AS text) WITH INOUT AS IMPLICIT;
-- todo [breaking]: use small table as enum? https://www.graphile.org/postgraphile/enums/#with-enum-tables

CREATE TABLE "gtfs".routes (
	route_id TEXT PRIMARY KEY,
	agency_id TEXT,
	FOREIGN KEY (agency_id) REFERENCES "gtfs".agency,
	-- todo: Either route_short_name or route_long_name must be specified, or potentially both if appropriate.
	route_short_name TEXT,
	route_long_name TEXT,
	route_desc TEXT,
	route_type "gtfs".route_type_val NOT NULL,
	route_url TEXT,
	route_color TEXT,
	route_text_color TEXT,
	route_sort_order INT
);

CREATE INDEX ON "gtfs".routes (route_short_name);

-- trips
-----------------

CREATE TYPE "gtfs".wheelchair_accessibility AS ENUM (
	'unknown' -- 0 or empty - No accessibility information for the trip.
	, 'accessible' -- 1 – Vehicle being used on this particular trip can accommodate at least one rider in a wheelchair.
	, 'not_accessible' -- 2 – No riders in wheelchairs can be accommodated on this trip.
);
CREATE CAST ("gtfs".wheelchair_accessibility AS text) WITH INOUT AS IMPLICIT;

CREATE TYPE "gtfs".bikes_allowance AS ENUM (
	'unknown' -- 0 or empty - No bike information for the trip.
	, 'allowed' -- 1 – Vehicle being used on this particular trip can accommodate at least one bicycle.
	, 'not_allowed' -- 2 – No bicycles are allowed on this trip.
);
CREATE CAST ("gtfs".bikes_allowance AS text) WITH INOUT AS IMPLICIT;

CREATE TABLE "gtfs".trips (
	trip_id TEXT PRIMARY KEY,
	route_id TEXT NOT NULL,
	FOREIGN KEY (route_id) REFERENCES "gtfs".routes,
	service_id TEXT NOT NULL, -- references "gtfs".service_days.service_id
	trip_headsign TEXT,
	trip_short_name TEXT,
	direction_id INT,
	block_id TEXT,
	shape_id TEXT, -- todo: add NOT NULL?
	CONSTRAINT valid_shape_id CHECK ("gtfs".shape_exists(shape_id)),
	-- todo [breaking]: use 0/unknown for empty values
	wheelchair_accessible "gtfs".wheelchair_accessibility,
	-- todo [breaking]: use 0/unknown for empty values
	bikes_allowed "gtfs".bikes_allowance
);

CREATE INDEX ON "gtfs".trips (route_id);

-- frequencies
-----------------

CREATE TYPE "gtfs".exact_times_v AS ENUM (
	'frequency_based' -- 0 or empty - Frequency-based trips.
	, 'schedule_based' -- 1 – Schedule-based trips with the exact same headway throughout the day. In this case the end_time value must be greater than the last desired trip start_time but less than the last desired trip start_time + headway_secs.
);
CREATE CAST ("gtfs".exact_times_v AS text) WITH INOUT AS IMPLICIT;

CREATE TABLE "gtfs".frequencies (
	-- Used to implement arrivals_departures & connections. Filled after COPY-ing, see below.
	frequencies_row INTEGER,
	trip_id TEXT NOT NULL,
	FOREIGN KEY (trip_id) REFERENCES "gtfs".trips,
	start_time INTERVAL NOT NULL,
	end_time INTERVAL NOT NULL,
	headway_secs INT NOT NULL,
	exact_times "gtfs".exact_times_v,
	-- frequencies' primary key currently is just (trip_id, start_time)
	-- see also https://github.com/google/transit/issues/514
	-- todo: add primary key?
	UNIQUE (
		trip_id,
		start_time,
		end_time,
		headway_secs,
		exact_times
	)
);

CREATE INDEX ON "gtfs".frequencies (trip_id);
CREATE INDEX ON "gtfs".frequencies (exact_times);

-- stops
-----------------

CREATE TYPE "gtfs".location_type_val AS ENUM (
	'stop' -- 0 (or blank): Stop (or Platform). A location where passengers board or disembark from a transit vehicle. Is called a platform when defined within a parent_station.
	, 'station' -- 1 – Station. A physical structure or area that contains one or more platform.
	, 'entrance_exit' -- 2 – Entrance/Exit. A location where passengers can enter or exit a station from the street. If an entrance/exit belongs to multiple stations, it can be linked by pathways to both, but the data provider must pick one of them as parent.
	, 'node' -- 3 – Generic Node. A location within a station, not matching any other location_type, which can be used to link together pathways define in pathways.txt.
	, 'boarding_area' -- 4 – Boarding Area. A specific location on a platform, where passengers can board and/or alight vehicles.
);
CREATE CAST ("gtfs".location_type_val AS text) WITH INOUT AS IMPLICIT;

-- For parentless stops:
-- 0 or empty - No accessibility information for the stop.
-- 1 - Some vehicles at this stop can be boarded by a rider in a wheelchair.
-- 2 - Wheelchair boarding is not possible at this stop.

-- For child stops:
-- 0 or empty - Stop will inherit its wheelchair_boarding behavior from the parent station, if specified in the parent.
-- 1 - There exists some accessible path from outside the station to the specific stop/platform.
-- 2 - There exists no accessible path from outside the station to the specific stop/platform.

-- For station entrances/exits:
-- 0 or empty - Station entrance will inherit its wheelchair_boarding behavior from the parent station, if specified for the parent.
-- 1 - Station entrance is wheelchair accessible.
-- 2 - No accessible path from station entrance to stops/platforms.
CREATE TYPE "gtfs".wheelchair_boarding_val AS ENUM (
	'no_info_or_inherit'
	, 'accessible'
	, 'not_accessible'
);
CREATE CAST ("gtfs".wheelchair_boarding_val AS text) WITH INOUT AS IMPLICIT;

CREATE TABLE "gtfs".stops (
	stop_id TEXT PRIMARY KEY,
	stop_code TEXT,
	-- todo: Required for locations which are stops (location_type=0), stations (location_type=1) or entrances/exits (location_type=2). Optional for locations which are generic nodes (location_type=3) or boarding areas (location_type=4).
	stop_name TEXT,
	stop_desc TEXT,
	stop_loc geography(POINT), -- stop_lat/stop_lon
	zone_id TEXT,
	stop_url TEXT,
	location_type "gtfs".location_type_val,
	parent_station TEXT,
	stop_timezone TEXT CHECK ("gtfs".is_timezone(stop_timezone)),
	wheelchair_boarding "gtfs".wheelchair_boarding_val,
	level_id TEXT,

	platform_code TEXT
);

ALTER TABLE "gtfs".stops
ADD CONSTRAINT stops_parent_station_fkey
FOREIGN KEY (parent_station) REFERENCES "gtfs".stops;

CREATE INDEX ON "gtfs".stops (parent_station);

-- stop_times
-----------------

CREATE TYPE "gtfs".pickup_drop_off_type AS ENUM (
	'regular' -- 0 or empty - Regularly scheduled pickup/dropoff.
	, 'not_available' -- 1 – No pickup/dropoff available.
	, 'call' -- 2 – Must phone agency to arrange pickup/dropoff.
	, 'driver' -- 3 – Must coordinate with driver to arrange pickup/dropoff.
);
CREATE CAST ("gtfs".pickup_drop_off_type AS text) WITH INOUT AS IMPLICIT;

CREATE TYPE "gtfs".timepoint_v AS ENUM (
	'approximate' -- 0 – Times are considered approximate.
	, 'exact' -- 1 or empty - Times are considered exact.
);
CREATE CAST ("gtfs".timepoint_v AS text) WITH INOUT AS IMPLICIT;

CREATE TABLE "gtfs".stop_times (
	trip_id TEXT NOT NULL,
	FOREIGN KEY (trip_id) REFERENCES "gtfs".trips,
	-- https://gist.github.com/derhuerst/574edc94981a21ef0ce90713f1cff7f6
	arrival_time INTERVAL,
	departure_time INTERVAL,
	stop_id TEXT NOT NULL,
	FOREIGN KEY (stop_id) REFERENCES "gtfs".stops,
	stop_sequence INT NOT NULL,
	stop_sequence_consec INT,
	stop_headsign TEXT,
	pickup_type "gtfs".pickup_drop_off_type,
	drop_off_type "gtfs".pickup_drop_off_type,
	shape_dist_traveled REAL,
	timepoint "gtfs".timepoint_v,
	-- Used to implement frequencies.txt. Filled after COPY-ing, see below.
	trip_start_time INTERVAL
);

-- trip_start_time is used to implement frequencies.txt.
UPDATE "gtfs".stop_times
-- This is ugly, but AFAICT there is no cleaner way.
-- see also https://stackoverflow.com/a/4359354/1072129
SET trip_start_time = t.trip_start_time
FROM (
	SELECT
		-- todo: is frequencies.txt relative to 1st arrival_time or departure_time?
		coalesce(
			first_value(departure_time) OVER (PARTITION BY trip_id ORDER BY stop_sequence),
			first_value(arrival_time) OVER (PARTITION BY trip_id ORDER BY stop_sequence)
		) AS trip_start_time,
		trip_id, stop_sequence
	FROM "gtfs".stop_times
) AS t
-- self-join
WHERE stop_times.trip_id = t.trip_id
AND stop_times.stop_sequence = t.stop_sequence;

CREATE INDEX ON "gtfs".stop_times (trip_id);
CREATE INDEX ON "gtfs".stop_times (stop_id);

CREATE INDEX ON "gtfs".stop_times (stop_sequence_consec);
CREATE INDEX ON "gtfs".stop_times (trip_id, stop_sequence_consec);
CREATE INDEX ON "gtfs".stop_times (arrival_time DESC NULLS LAST);
CREATE INDEX ON "gtfs".stop_times (departure_time DESC NULLS LAST);
-- todo: are these two necessary?
CREATE INDEX ON "gtfs".stop_times (arrival_time);
CREATE INDEX ON "gtfs".stop_times (departure_time);

CREATE OR REPLACE FUNCTION "gtfs".largest_departure_time ()
RETURNS interval AS $$
	SELECT departure_time
	FROM "gtfs".stop_times
	WHERE EXISTS (
		SELECT *
		FROM "gtfs".trips
		JOIN "gtfs".service_days ON service_days.service_id = trips.service_id
		WHERE trips.trip_id = stop_times.trip_id
	)
	ORDER BY departure_time DESC NULLS LAST
	LIMIT 1;
$$ LANGUAGE SQL IMMUTABLE;
CREATE OR REPLACE FUNCTION "gtfs".largest_arrival_time ()
RETURNS interval AS $$
	SELECT arrival_time
	FROM "gtfs".stop_times
	WHERE EXISTS (
		SELECT *
		FROM "gtfs".trips
		JOIN "gtfs".service_days ON service_days.service_id = trips.service_id
		WHERE trips.trip_id = stop_times.trip_id
	)
	ORDER BY arrival_time DESC NULLS LAST
	LIMIT 1;
$$ LANGUAGE SQL IMMUTABLE;
CREATE OR REPLACE FUNCTION "gtfs".dates_filter_min (
	_timestamp TIMESTAMP WITH TIME ZONE
)
RETURNS date AS $$
	SELECT date_trunc(
		'day',
		_timestamp
		- GREATEST(
			"gtfs".largest_arrival_time(),
			"gtfs".largest_departure_time()
		)
		-- we assume the DST <-> standard time shift is always <= 1h
		- '1 hour 1 second'::interval
	);
$$ LANGUAGE SQL IMMUTABLE;
-- This function doesn't do much, we just provide it to match date_filter_min().
CREATE OR REPLACE FUNCTION "gtfs".dates_filter_max (
	_timestamp TIMESTAMP WITH TIME ZONE
)
RETURNS date AS $$
	SELECT date_trunc('day', _timestamp);
$$ LANGUAGE SQL IMMUTABLE;

CREATE OR REPLACE VIEW "gtfs".arrivals_departures AS
WITH stop_times_based AS NOT MATERIALIZED (
	SELECT
		agency.agency_id,
		trips.route_id,
		route_short_name,
		route_long_name,
		route_type,
		s.trip_id,
		trips.direction_id,
		trips.trip_headsign,
		trips.wheelchair_accessible,
		trips.bikes_allowed,
		service_days.service_id,
		trips.shape_id,
		"date",
		stop_sequence,
		stop_sequence_consec,
		stop_headsign,
		pickup_type,
		drop_off_type,
		shape_dist_traveled,
		timepoint,
		agency.agency_timezone as tz,
		arrival_time,
		(
			make_timestamptz(
				date_part('year', "date")::int,
				date_part('month', "date")::int,
				date_part('day', "date")::int,
				12, 0, 0,
				agency.agency_timezone
			)
			- INTERVAL '12 hours'
			+ arrival_time
		) t_arrival,
		departure_time,
		(
			make_timestamptz(
				date_part('year', "date")::int,
				date_part('month', "date")::int,
				date_part('day', "date")::int,
				12, 0, 0,
				agency.agency_timezone
			)
			- INTERVAL '12 hours'
			+ departure_time
		) t_departure,
		trip_start_time,
		s.stop_id, stops.stop_name,
		stations.stop_id station_id, stations.stop_name station_name,
		-- todo: PR #47
		coalesce(
			nullif(stops.wheelchair_boarding, 'no_info_or_inherit'),
			nullif(stations.wheelchair_boarding, 'no_info_or_inherit'),
			'no_info_or_inherit'
		) AS wheelchair_boarding
	FROM (
		"gtfs".stop_times s
		JOIN "gtfs".stops ON s.stop_id = stops.stop_id
		LEFT JOIN "gtfs".stops stations ON stops.parent_station = stations.stop_id
		JOIN "gtfs".trips ON s.trip_id = trips.trip_id
		JOIN "gtfs".routes ON trips.route_id = routes.route_id
		LEFT JOIN "gtfs".agency ON (
			-- The GTFS spec allows routes.agency_id to be NULL if there is exactly one agency in the feed.
			-- Note: We implicitly rely on other parts of the code base to validate that agency has just one row!
			-- It seems that GTFS has allowed this at least since 2016:
			-- https://github.com/google/transit/blame/217e9bf/gtfs/spec/en/reference.md#L544-L554
			routes.agency_id IS NULL -- match first (and only) agency
			OR routes.agency_id = agency.agency_id -- match by ID
		)
		JOIN "gtfs".service_days ON trips.service_id = service_days.service_id
	)
	-- todo: this slows down slightly
	-- ORDER BY route_id, s.trip_id, "date", stop_sequence
)
-- stop_times-based arrivals/departures
SELECT
	(
		encode(trip_id::bytea, 'base64')
		|| ':' || encode((
			extract(ISOYEAR FROM "date")
			|| '-' || lpad(extract(MONTH FROM "date")::text, 2, '0')
			|| '-' || lpad(extract(DAY FROM "date")::text, 2, '0')
		)::bytea, 'base64')
		|| ':' || encode((stop_sequence::text)::bytea, 'base64')
		-- frequencies_row
		|| ':' || encode('-1'::bytea, 'base64')
		-- frequencies_it
		|| ':' || encode('-1'::bytea, 'base64')
	) as arrival_departure_id,

	stop_times_based.*,
	-- todo: expose local arrival/departure "wall clock time"?

	-1 AS frequencies_row,
	-1 AS frequencies_it
FROM stop_times_based
UNION ALL
-- frequencies-based arrivals/departures
SELECT
	(
		encode(trip_id::bytea, 'base64')
		|| ':' || encode((
			extract(ISOYEAR FROM "date")
			|| '-' || lpad(extract(MONTH FROM "date")::text, 2, '0')
			|| '-' || lpad(extract(DAY FROM "date")::text, 2, '0')
		)::bytea, 'base64')
		|| ':' || encode((stop_sequence::text)::bytea, 'base64')
		|| ':' || encode((frequencies_row::text)::bytea, 'base64')
		|| ':' || encode((frequencies_it::text)::bytea, 'base64')
	) as arrival_departure_id,
	*
FROM (
SELECT
	*,
	row_number() OVER (PARTITION BY trip_id, "date", frequencies_row, stop_sequence_consec ORDER BY t_departure ASC)::integer AS frequencies_it
FROM (
SELECT
	-- stop_times_based.* except t_arrival & t_departure, duh
	-- todo: find a way to use all columns without explicitly enumerating them here
	agency_id,
	route_id, route_short_name, route_long_name, route_type,
	trip_id, direction_id, trip_headsign, wheelchair_accessible, bikes_allowed,
	service_id,
	shape_id,
	"date",
	stop_sequence, stop_sequence_consec,
	stop_headsign, pickup_type, drop_off_type, shape_dist_traveled, timepoint,
	tz,
	arrival_time, -- todo [breaking]: this is misleading, remove it
	generate_series(
		t_arrival - trip_start_time + start_time,
		t_arrival - trip_start_time + end_time,
		INTERVAL '1 second' * headway_secs
	) as t_arrival,
	departure_time, -- todo [breaking]: this is misleading, remove it
	generate_series(
		t_departure - trip_start_time + start_time,
		t_departure - trip_start_time + end_time,
		INTERVAL '1 second' * headway_secs
	) as t_departure,
	trip_start_time,
	stop_id, stop_name,
	station_id, station_name,
	wheelchair_boarding,
	frequencies_row
FROM (
	SELECT
		stop_times_based.*,
		frequencies.start_time,
		frequencies.end_time,
		frequencies.headway_secs,
		frequencies_row
	FROM stop_times_based
	JOIN "gtfs".frequencies ON frequencies.trip_id = stop_times_based.trip_id
	WHERE frequencies.exact_times = 'schedule_based' -- todo: is this correct?
) t
) t
) frequencies_based;

CREATE OR REPLACE FUNCTION "gtfs".arrival_departure_by_arrival_departure_id(id TEXT)
RETURNS "gtfs".arrivals_departures
AS $$
	SELECT *
	FROM "gtfs".arrivals_departures
	WHERE trip_id = convert_from(decode(split_part(id, ':', 1), 'base64'), 'UTF-8')::text
	AND "date" = (convert_from(decode(split_part(id, ':', 2), 'base64'), 'UTF-8')::text)::timestamp
	AND stop_sequence = (convert_from(decode(split_part(id, ':', 3), 'base64'), 'UTF-8')::text)::integer
	AND (convert_from(decode(split_part(id, ':', 4), 'base64'), 'UTF-8')::text)::integer = frequencies_row
	AND (convert_from(decode(split_part(id, ':', 5), 'base64'), 'UTF-8')::text)::integer = frequencies_it
	-- todo: what if there are >1 rows?
	LIMIT 1;
$$ LANGUAGE SQL STABLE STRICT;


CREATE OR REPLACE VIEW "gtfs".connections AS
WITH stop_times_based AS NOT MATERIALIZED (
	SELECT
		route_id,
		route_short_name,
		route_long_name,
		route_type,
		trip_id,
		trips.service_id,
		trips.direction_id,
		trips.trip_headsign,
  		trips.wheelchair_accessible,
		trips.bikes_allowed,
		trip_start_time,

		from_stop_id,
		from_stop_name,
		from_station_id,
		from_station_name,
		from_wheelchair_boarding,

		from_stop_headsign,
		from_pickup_type,
		make_timestamptz(
			date_part('year'::text, "date")::integer,
			date_part('month'::text, "date")::integer,
			date_part('day'::text, "date")::integer,
			12, 0, 0::double precision,
			agency_timezone
		) - '12:00:00'::interval + departure_time AS t_departure,
		departure_time,
		from_stop_sequence,
		from_stop_sequence_consec,
		from_timepoint,
		"date",
		to_timepoint,
		to_stop_sequence,
		to_stop_sequence_consec,
		make_timestamptz(
			date_part('year'::text, "date")::integer,
			date_part('month'::text, "date")::integer,
			date_part('day'::text, "date")::integer,
			12, 0, 0::double precision,
			agency_timezone
		) - '12:00:00'::interval + arrival_time AS t_arrival,
		arrival_time,
		to_drop_off_type,
		to_stop_headsign,

		to_stop_id,
		to_stop_name,
		to_station_id,
		to_station_name,
		to_wheelchair_boarding
	FROM (
		SELECT
			trips.route_id,
			route_short_name,
			route_long_name,
			route_type,
			stop_times.trip_id, -- not using trips.trip_id here for the query optimizer
			trips.service_id,
			trips.direction_id,
			trips.trip_headsign,
   			trips.wheelchair_accessible,
			trips.bikes_allowed,
			agency.agency_timezone,
			stop_times.trip_start_time,

			from_stops.stop_id as from_stop_id,
			from_stops.stop_name as from_stop_name,
			from_stations.stop_id as from_station_id,
			from_stations.stop_name as from_station_name,
			-- todo: PR #47
			coalesce(
				nullif(from_stops.wheelchair_boarding, 'no_info_or_inherit'),
				nullif(from_stations.wheelchair_boarding, 'no_info_or_inherit'),
				'no_info_or_inherit'
			) AS from_wheelchair_boarding,

			stop_times.stop_headsign as from_stop_headsign,
			stop_times.pickup_type as from_pickup_type,
			stop_times.departure_time as departure_time,
			stop_times.stop_sequence as from_stop_sequence,
			stop_times.stop_sequence_consec as from_stop_sequence_consec,
			stop_times.timepoint as from_timepoint,

			to_stop_times.timepoint as to_timepoint,
			to_stop_times.stop_sequence as to_stop_sequence,
			to_stop_times.stop_sequence_consec as to_stop_sequence_consec,
			to_stop_times.arrival_time as arrival_time,
			to_stop_times.drop_off_type as to_drop_off_type,
			to_stop_times.stop_headsign as to_stop_headsign,

			to_stop_times.stop_id as to_stop_id,
			to_stops.stop_name as to_stop_name,
			to_stations.stop_id as to_station_id,
			to_stations.stop_name as to_station_name,
			-- todo: PR #47
			coalesce(
				nullif(to_stops.wheelchair_boarding, 'no_info_or_inherit'),
				nullif(to_stations.wheelchair_boarding, 'no_info_or_inherit'),
				'no_info_or_inherit'
			) AS to_wheelchair_boarding
		FROM "gtfs".trips
		LEFT JOIN "gtfs".routes ON trips.route_id = routes.route_id
		LEFT JOIN "gtfs".agency ON (
			-- The GTFS spec allows routes.agency_id to be NULL if there is exactly one agency in the feed.
			-- Note: We implicitly rely on other parts of the code base to validate that agency has just one row!
			-- It seems that GTFS has allowed this at least since 2016:
			-- https://github.com/google/transit/blame/217e9bf/gtfs/spec/en/reference.md#L544-L554
			routes.agency_id IS NULL -- match first (and only) agency
			OR routes.agency_id = agency.agency_id -- match by ID
		)
		LEFT JOIN "gtfs".stop_times ON trips.trip_id = stop_times.trip_id
		LEFT JOIN "gtfs".stops from_stops ON stop_times.stop_id = from_stops.stop_id
		LEFT JOIN "gtfs".stops from_stations ON from_stops.parent_station = from_stations.stop_id
		INNER JOIN "gtfs".stop_times to_stop_times ON stop_times.trip_id = to_stop_times.trip_id AND stop_times.stop_sequence_consec + 1 = to_stop_times.stop_sequence_consec
		INNER JOIN "gtfs".stops to_stops ON to_stop_times.stop_id = to_stops.stop_id
		LEFT JOIN "gtfs".stops to_stations ON to_stops.parent_station = to_stations.stop_id
	) trips
	JOIN (
		SELECT *
		FROM "gtfs".service_days
		ORDER BY service_id, "date"
	) service_days ON trips.service_id = service_days.service_id
)
-- stop_times-based connections
SELECT
	(
		encode(trip_id::bytea, 'base64')
		|| ':' || encode((
			extract(ISOYEAR FROM "date")
			|| '-' || lpad(extract(MONTH FROM "date")::text, 2, '0')
			|| '-' || lpad(extract(DAY FROM "date")::text, 2, '0')
		)::bytea, 'base64')
		|| ':' || encode((from_stop_sequence::text)::bytea, 'base64')
		-- frequencies_row
		|| ':' || encode('-1'::bytea, 'base64')
		-- frequencies_it
		|| ':' || encode('-1'::bytea, 'base64')
	) as connection_id,

	stop_times_based.*,

	-1 AS frequencies_row,
	-1 AS frequencies_it
FROM stop_times_based
UNION ALL
-- frequencies-based connections
SELECT
	(
		encode(trip_id::bytea, 'base64')
		|| ':' || encode((
			extract(ISOYEAR FROM "date")
			|| '-' || lpad(extract(MONTH FROM "date")::text, 2, '0')
			|| '-' || lpad(extract(DAY FROM "date")::text, 2, '0')
		)::bytea, 'base64')
		|| ':' || encode((from_stop_sequence::text)::bytea, 'base64')
		|| ':' || encode((frequencies_row::text)::bytea, 'base64')
		|| ':' || encode((frequencies_it::text)::bytea, 'base64')
	) as connection_id,

	frequencies_based.*
FROM (
SELECT
	*,
	row_number() OVER (PARTITION BY trip_id, "date", frequencies_row, from_stop_sequence_consec ORDER BY t_departure ASC)::integer AS frequencies_it
FROM (
SELECT
	-- stop_times_based.* except t_arrival & t_departure, duh
	-- todo: find a way to use all columns without explicitly enumerating them here
	route_id, route_short_name, route_long_name, route_type,
	trip_id,
	service_id,
	direction_id,
	trip_headsign,
 	wheelchair_accessible,
	bikes_allowed,
	trip_start_time,

	from_stop_id,
	from_stop_name,
	from_station_id,
	from_station_name,
	from_wheelchair_boarding,

	from_stop_headsign,
	from_pickup_type,
	generate_series(
		t_departure - trip_start_time + start_time,
		t_departure - trip_start_time + end_time,
		INTERVAL '1 second' * headway_secs
	) as t_departure,
	departure_time, -- todo [breaking]: this is misleading, remove it
	from_stop_sequence,
	from_stop_sequence_consec,
	from_timepoint,

	"date",

	to_timepoint,
	to_stop_sequence,
	to_stop_sequence_consec,
	generate_series(
		t_arrival - trip_start_time + start_time,
		t_arrival - trip_start_time + end_time,
		INTERVAL '1 second' * headway_secs
	) as t_arrival,
	arrival_time, -- todo [breaking]: this is misleading, remove it
	to_drop_off_type,
	to_stop_headsign,

	to_stop_id,
	to_stop_name,
	to_station_id,
	to_station_name,
	to_wheelchair_boarding,

	frequencies_row
FROM (
	SELECT
		stop_times_based.*,
		frequencies.start_time,
		frequencies.end_time,
		frequencies.headway_secs,
		frequencies_row
	FROM stop_times_based
	JOIN "gtfs".frequencies ON frequencies.trip_id = stop_times_based.trip_id
	WHERE frequencies.exact_times = 'schedule_based' -- todo: is this correct?
) t
) t
) frequencies_based;

CREATE OR REPLACE FUNCTION "gtfs".connection_by_connection_id(id TEXT)
RETURNS "gtfs".connections
AS $$
	SELECT *
	FROM "gtfs".connections
	WHERE trip_id = convert_from(decode(split_part(id, ':', 1), 'base64'), 'UTF-8')::text
	AND "date" = (convert_from(decode(split_part(id, ':', 2), 'base64'), 'UTF-8')::text)::timestamp
	AND from_stop_sequence = (convert_from(decode(split_part(id, ':', 3), 'base64'), 'UTF-8')::text)::integer
	AND (convert_from(decode(split_part(id, ':', 4), 'base64'), 'UTF-8')::text)::integer = frequencies_row
	AND (convert_from(decode(split_part(id, ':', 5), 'base64'), 'UTF-8')::text)::integer = frequencies_it
	-- todo: what if there are >1 rows?
	LIMIT 1;
$$ LANGUAGE SQL STABLE STRICT;

-- stats_by_route_date
-----------------

CREATE OR REPLACE VIEW "gtfs".stats_by_route_date AS
WITH
	arrs_deps_with_svc_date AS NOT MATERIALIZED (
		SELECT
			route_id, stop_sequence_consec,
			"date"::date AS svc_date,
			EXTRACT(DOW FROM "date") AS svc_dow
		FROM "gtfs".arrivals_departures
	),
	by_svc_date AS NOT MATERIALIZED (
		SELECT DISTINCT ON (route_id, svc_date)
			route_id,
			svc_date AS "date",
			svc_dow AS dow,
			count(*) FILTER (WHERE stop_sequence_consec = 0) OVER (PARTITION BY route_id, svc_date) AS nr_of_trips,
			count(*) OVER (PARTITION BY route_id, svc_date) AS nr_of_arrs_deps
		FROM arrs_deps_with_svc_date
	),
	arrs_deps_with_effective_date AS NOT MATERIALIZED (
		SELECT
			route_id, stop_sequence_consec,
			coalesce(t_departure, t_arrival)::date AS effective_date,
			EXTRACT(DOW FROM coalesce(t_departure, t_arrival)) AS effective_dow
		FROM "gtfs".arrivals_departures
	),
	by_effective_date AS NOT MATERIALIZED (
		SELECT DISTINCT ON (route_id, effective_date)
			route_id,
			effective_date AS "date",
			effective_dow AS dow,
			count(*) FILTER (WHERE stop_sequence_consec = 0) OVER (PARTITION BY route_id, effective_date) AS nr_of_trips,
			count(*) OVER (PARTITION BY route_id, effective_date) AS nr_of_arrs_deps
		FROM arrs_deps_with_effective_date
	)
SELECT
	*,
	True AS is_effective
FROM by_effective_date
UNION
SELECT
	*,
	False AS is_effective
FROM by_svc_date;

-- stats_by_agency_route_stop_hour
-----------------

CREATE OR REPLACE VIEW "gtfs".stats_by_agency_route_stop_hour AS
SELECT DISTINCT ON (agency_id, route_id, stop_id, effective_hour)
	agency_id, route_id, stop_id, station_id,
	"date" as service_date,
	date_trunc('hour', t_arrival) AS effective_hour,
	count(*) OVER (PARTITION BY route_id, stop_id, date_trunc('hour', t_arrival)) AS nr_of_arrs
FROM "gtfs".arrivals_departures;

-- stats_active_trips_by_hour
-----------------

CREATE MATERIALIZED VIEW "gtfs".feed_time_frame AS
WITH
	dates AS (
		SELECT
			min("date") AS min,
			max("date") AS max
		FROM "gtfs".service_days
	),
	date_offset AS (
		SELECT greatest(
			"gtfs".largest_arrival_time(),
			"gtfs".largest_departure_time()
		) AS o
	),
	date_min_max AS (
		SELECT
			date_trunc('day', min + o) AS min,
			date_trunc('day', max - o) AS max
		FROM dates, date_offset
	),
	min_dep AS (
		SELECT min("t_departure") AS t
		FROM "gtfs".arrivals_departures, date_min_max
		WHERE date <= (SELECT min FROM date_min_max)
	),
	min_arr AS (
		SELECT min("t_arrival") AS t
		FROM "gtfs".arrivals_departures, date_min_max
		WHERE date <= (SELECT min FROM date_min_max)
	),
	max_dep AS (
		SELECT min("t_departure") AS t
		FROM "gtfs".arrivals_departures, date_min_max
		WHERE date >= (SELECT max FROM date_min_max)
	),
	max_arr AS (
		SELECT min("t_arrival") AS t
		FROM "gtfs".arrivals_departures, date_min_max
		WHERE date >= (SELECT max FROM date_min_max)
	)
SELECT
	least(min_dep.t, min_arr.t) as min,
	least(max_dep.t, max_arr.t) as max
FROM min_dep, min_arr, max_dep, max_arr;

CREATE OR REPLACE FUNCTION "gtfs".feed_time_series(
	time_unit TEXT
)
RETURNS SETOF timestamptz
AS $$
	SELECT
		generate_series(
			date_trunc(time_unit, min),
			date_trunc(time_unit, max),
			('1 ' || time_unit)::interval
		) as t
	FROM "gtfs".feed_time_frame
$$ LANGUAGE sql STABLE;

CREATE OR REPLACE VIEW "gtfs".stats_active_trips_by_hour AS
WITH
	all_hours AS NOT MATERIALIZED (
		SELECT "gtfs".feed_time_series('hour') AS "hour"
	)
SELECT DISTINCT ON ("hour")
	"hour",
	count(*) OVER (PARTITION BY "hour") as nr_of_active_trips
FROM (
	-- only keep one arrival/departure per trip
	SELECT DISTINCT ON ("hour", route_id, trip_id)
		*
	FROM (
		SELECT *
		FROM all_hours
		LEFT JOIN "gtfs".connections ON (
			date_trunc('hour', t_departure) <= "hour"
			AND date_trunc('hour', t_arrival) >= "hour"
		)
	) t
) cons;

-- feed_info
-----------------

-- The MobilityData GTFS Validator just uses Java's Locale#toLanguageTag() to validate *_lang.
-- https://github.com/MobilityData/gtfs-validator/blob/31ff374800f7d7883fd9de91b71049c2a4de4e45/main/src/main/java/org/mobilitydata/gtfsvalidator/validator/MatchingFeedAndAgencyLangValidator.java#L82
-- https://docs.oracle.com/javase/7/docs/api/java/util/Locale.html
-- related: https://github.com/google/transit/pull/98
CREATE TABLE "gtfs".feed_info (
	feed_publisher_name TEXT PRIMARY KEY,
	feed_publisher_url TEXT NOT NULL,
	feed_lang TEXT NOT NULL
		CONSTRAINT valid_feed_lang CHECK (
			"gtfs".is_valid_lang_code(feed_lang)
		),
	default_lang TEXT
		CONSTRAINT valid_default_lang CHECK (
			default_lang IS NULL OR "gtfs".is_valid_lang_code(default_lang)
		),
	feed_start_date DATE,
	feed_end_date DATE,
	feed_version TEXT,
	feed_contact_email TEXT,
	feed_contact_url TEXT
);

-- transfers
-----------------

CREATE TYPE "gtfs".transfer_type_v AS ENUM (
	'recommended' -- 0 or empty - Recommended transfer point between routes.
	, 'timed' -- 1 - Timed transfer point between two routes. The departing vehicle is expected to wait for the arriving one and leave sufficient time for a rider to transfer between routes.
	, 'minimum_time' -- 2 – Transfer requires a minimum amount of time between arrival and departure to ensure a connection. The time required to transfer is specified by min_transfer_time.
	, 'impossible' -- 3 - Transfers are not possible between routes at the location.
);
CREATE CAST ("gtfs".transfer_type_v AS text) WITH INOUT AS IMPLICIT;

CREATE TABLE "gtfs".transfers (
	id SERIAL PRIMARY KEY,
	from_stop_id TEXT,
	FOREIGN KEY (from_stop_id) REFERENCES "gtfs".stops,
	to_stop_id TEXT,
	FOREIGN KEY (to_stop_id) REFERENCES "gtfs".stops,
	transfer_type "gtfs".transfer_type_v,
	min_transfer_time INT,
	from_route_id TEXT,
	FOREIGN KEY (from_route_id) REFERENCES "gtfs".routes,
	to_route_id TEXT,
	FOREIGN KEY (to_route_id) REFERENCES "gtfs".routes, -- SkytrainSim: Fix foreign key field
	from_trip_id TEXT,
	FOREIGN KEY (from_trip_id) REFERENCES "gtfs".trips, -- SkytrainSim: Fix foreign key field
	to_trip_id TEXT,
	FOREIGN KEY (to_trip_id) REFERENCES "gtfs".trips -- SkytrainSim: Fix foreign key field
);

ALTER TABLE "gtfs".transfers
ADD CONSTRAINT transfers_sig
UNIQUE (
	from_stop_id,
	to_stop_id,
	from_route_id,
	to_route_id,
	from_trip_id,
	to_trip_id
);
